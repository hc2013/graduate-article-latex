\chapter{系统详细设计与实现}

\section{轨迹检索服务详细设计}
\subsection{概述}
轨迹检索服务是在全文检索引擎ElasticSearch的基础上，扩展实现了单独的优先点树索引结构来实现的。由于服务对外接口访问，分布式，故障检测等功能由ElasticSearch提供，因此本文只关注具体索引结构的设计和实现。
轨迹检索服务的核心思想是，以JTS-Geometry作为路径的存储形式，也就是只考虑路径的几何展现，不去考虑路径的方向性。并以豪斯多夫距离衡量两个Geometry之间的距离。两个Geometry之间的豪斯多夫距离越短，就认为两个Geometry越相似，也就认为两个路径越相似。基于这样的前提，我们将Geometry作为度量空间中的数据点，实际上把相似路径检索问题转化为Geometry的KNN问题，然后通过建立vp-tree的数据结构，进行求解。\textbf{注意：由于算法实现流程的细节较多，本文采用流程+实现+设计要点的顺序进行阐述，其中设计要点是对主流程实现细节的单独阐述。}
\subsection{优先点树索引类图}
\begin{figure}[htp]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/vp-tree-general-structure.pdf}
  \caption{优先点树索引类图}\label{vp-tree-general-structure}
\end{figure}
如\ref{vp-tree-general-structure}所示，整个优先点树结构以VpTree为核心。其中VPTree直接实现了GeometryNNIndex这个接口，之所以要这样设计，是因为解决NN问题的索引结构并不是只有vpTree，另外还有Kd-Tree，R-Tree等等，本文所设计的VpTree只是其中一种。因此，预留接口。

Node是VpTree的实现的核心，是VpTree存储数据点Id，距离信息，子树边界，除此之外，Node类还需要对自身是否为叶子节点进行控制。Vptree的搜索算法最终都是运行在Node上的。

DistanceCahce是对距离的缓存结构，以减少数据点之间距离的计算次数。目前为止的实现中，DistanceCache并没有设计任何过期替换策略，所以在运行时可能会出现大量占用内存的状况，在未来的版本中，会优化这一点。

BitSetContext用于记录VpTree一条检索路径中各个非叶节点的分支已搜索状态，用于避免重复检索。目前BitSetContext的实现中，依赖于外部的释放内存空间，BitSetContext本身没有设计垃圾回收机制。

Configuration类用于保存VpTree的初始化信息，例如扇出数，节点尺寸，采样率等。

BulkLoadContext是VpTree初始建树时输入参数，主要包括一个docIdList和一个Geometrylist。其主要功能是在初始建树的过程中提供数据。而GeomtrySorter是一个排序工具类，用于对BulkLoadContext中的几何体进行排序（多路切分），这个类是对快排的扩展实现。

GeomtryDistanceFunction是VpTree数据点间距离计算的接口，本文实现的算法HausdorffDistance采用豪斯多夫距离，但这显然不是唯一一种距离衡量方式。因此预留接口，以备扩充。

SelectVpStrategy是VpTree用于选择优先点的策略接口，本文目前只支持最大标准差的选取方法。未来可能会有更合理的实现。\textbf{其实，随即取优先点也是一种可选方式。}Sampler是取样器的实现类，在最大标准差SampleSelectVpStrategy的实现中，使用了采用器进行采样，目前的采样器的实现只有一种ReservoirSampler。

综上所述，整个VpTree结构的设计，是充分面对扩展的。对于未来可能出现的新的距离计算函数，采样方式，节点结构，数据点形式，有良好的适应性。只是在内存使用上，存在一定的瑕疵，这在未来版本的优化中会得到解决。

\subsection{优先点树节点结构}
本文所设计实现的优先点树的结构是对最简单vp-tree结构的改良，将原生vp-tree的两路结构改为多路结构。相应地，就需要把按中值进行二分修改为以边界值进行多分，并且为了提高检索的速度，减少检索时的距离运算量，改良后的vp-tree的非叶节点不仅存储了Vantage Point ID和每棵子树的指针，还存储了每个子树的距离值的上界和下界以及最大距离值。具体结构见图~\ref{vp-tree-structure1}所示为一个4路vp-tree的内部结构示意图。
\begin{figure}[htp]
  \centering
  \includegraphics[width=5in,height=3in]{new_FIGs/chapter4/vp-tree-structure1.pdf}
  \caption{4路vp-tree的内部结构示意图}\label{vp-tree-structure1}
\end{figure}
\subsection{初始建树的流程}
初始建树的输入数据是一系列的docId+Geometry，初始建树的输出是一颗完整的多路vp-tree。具体流程见~\ref{create-node-flow}。\textbf{注意：本文用DP来表示Data Point，即数据点，用VP来表示Vantage Point，即被选做优先点的数据点，用Node来表示vp-tree的节点。}

如图所示初始建树实际上是一个递归的过程。但是为了避免出现内存溢出，本文选择了用循环+栈的模式。流程开始时，首先将根节点压栈，然后判断数据点的个数是不是小于叶节点的数据量标准。如果是，就意味着已经达到终止这一分支的条件，则直接为叶节点，然后通过空流程返回循环判断。如果数据量仍然大于叶节点的数据量，就使用选取函数选择优先点，计算其他各个数据点到优先点的距离，再根据距离进行升序排序。\textbf{注意：由于此时有一个点被选做优先点，所以数据点总量要减一}，然后判断剩余的数据量是否大于扇出数，如果数据量已经不能满足全部的扇出，那么就初始化为单个非叶节点入栈，从而进入下一次循环。如果数据量依然足够分割全部的扇出，就按照距离排序的结果进行多路切分，用新建的子节点代表新的子树，并入栈。将距离值，上下界值和子节点指针分别填入对应的数组中，再进入下一次循环。以此类推，循环往复，完成所有数据点的建树操作。

\begin{figure}[htp]
  \centering
  \includegraphics[width=5in]{new_FIGs/chapter4/create-node-flow.pdf}
  \caption{初始建树流程图}\label{create-node-flow}
\end{figure}
\subsection{初始建树算法实现}
见图\ref{create-node-code}\textbf{注意，出于节省篇幅考虑，省略了部分简单实现}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/initVpTree-code.pdf}
  \caption{初始建树代码}\label{create-node-code}
\end{figure}
\subsection{设计要点1：使用长度栈和偏移量栈记录内存状态，避免冗余内存}
初始建树的输入数据是两端段很长的数组，分别保存了docID和对应的Geometry。为了减少内存使用，本文采用偏移量+长度这样的组合量来记录每个节点所涉及的数据状态，从而避免了输入数据的内存复制。另外，由于使用了栈实现，在多路划分的过程中，优先级是从右向左，而且是深度优先的。也就是说优先点树的最右边一个分支会最早完成创建。\textbf{由于vp-tree的多路切分是均衡的，所以vp-tree自然是一个平衡树，分支初始化的顺序与最终结果没有关系}。
\subsection{设计要点2：优先点的选择算法}
在初始建树的过程中，优先点选取是非常关键的一步。选取的好坏取决于一个优先点能否让切分出来的各路子树的边界值相差足够大，因为各路子树的边界值相差越大，在检索的时候，距离值落入某一子树的边界内的可能性越大，剪枝成功的可能性越高，性能就越好。反之，如果优先点选择很差，导致多个子树的上下界非常接近，就很容易出现一个距离值可能在多个子树中搜索的情况，造成性能下降。因此，如何选择尽可能优的优先点，是算法实现的重点。

本文针对优先点选择的实现是基于随记取样和标准差结果的。本文认为，一个点与其他点距离的标准差越大，作为优先点的性能越好，而由于数据全量很大，不可能都计算，就采用随机抽样的方式进行。其设计思路是，在数据点全集中随机取样K 个点，作为候选的优先点，针对这K 个候选的优先点进行循环遍历，每个候选优先点再随机取K 个点作为参照点，然后计算每个候选优先点和参考点之间距离的标准差，最后取标准差最大的那个候选点作为真正的优先点。具体实现如图~\ref{select-vp-code}所示。
\begin{figure}[htp]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/select-vp-code.pdf}
  \caption{优先点选取代码}\label{select-vp-code}
\end{figure}
\subsection{KNN问题的定义和解决思路}
在我们的轨迹检索服务的作用域内，K Nearest Neighbour的含义是，找到与目标Geometry距离最近的K个Geometry。

原生vp-tree的搜索算法是面对NN问题，也就是single nearest Neighbour问题，只招一个距离最近的点。那么面对KNN问题，显然不能通过简单地运用K次原生搜索算法来解决，那样毫无疑问会造成重大的性能损耗。

一个比较直观的想法是，使用一个大小为K的最小堆，在搜索过程中实时更新这个最小堆的状态，那么在搜索算法走完的时候，这个最小堆中的结果就是K个距离最近的Geomtry。这是\cite{DBLP:journals/vldb/FuCCM00}中所阐述的思路，本文实现的算法的借鉴了这一思路，同样是用堆来动态维护状态，但采取了一些措施应对这一思路的明显短板以获取更好的检索性能。详见下节。

\subsection{设计焦点：容忍距离的收敛起点和收敛速度}
在KNN问题的搜索过程中，对于每一个多路节点，除了考虑与优先点的距离之外，还要考虑一个容忍距离T,也就是超出这个容忍距离T的数据点不再予以考虑，这是距离范围剪枝的基本依据。显而易见的是，这个容忍距离越小，成功剪枝的概率越高，检索性能越好。但是如果容忍距离太小，又可能过度剪枝造成检索不到结果。所以容忍距离的收敛速度是直接影响检索性能的关键。

在上文所述的单纯用最小堆动态更新检索结果的算法中，其最大问题在于，容忍距离是从正无穷开始更新的。这使得检索从一开始完全不可能做到剪枝，容忍距离的收敛速度会非常慢，导致剪枝的效率很低，性能也比较差。

\subsection{检索算法实现思路概述}
基于上面所提到的容忍距离收敛较慢问题，本文采用了结果堆预填+回溯的方式进行优化处理。即通过原生vp-tree搜索算法，先找到single nearest neighbour，并保存从root到single nearest neighbour的整条路径。然后再通过整条路径的回溯先预填结果堆，这样以结果堆中最大距离作为容忍距离，再回溯整条路径中的节点，完成检索。这样通过预先填结果堆，使得容忍距离以更低的起点收敛，收敛的速度更快，性能更好。

\subsection{检索算法流程图}
\begin{figure}[htp]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/search-flow.pdf}
  \caption{检索算法流程图}\label{search-flow}
\end{figure}
\subsection{本文的算法实现的代码}
\begin{figure}[htp]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/findnn-code.pdf}
  \caption{检索最近邻居代码}\label{findnn-code}
\end{figure}
\begin{figure}[htp]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/trytoFillQueue-code.pdf}
  \caption{预填结果集代码}\label{trytoFillQueue-code}
\end{figure}
\subsection{设计焦点2：避免重复访问}
在当前的索引实现中，由于经历了预填结果集的操作，因此，在回溯过程中，可能会重复遍历相同的分支，导致性能损失。关于这一点，本文使用了BitSet栈的方式来实现，在预填结果集的过程中，与节点栈同步保存一个Bitset栈，两者的顺序一致。每个bitset与vp-tree的扇出数一致，用于保存若干分支中，哪些已经被访问过了。这样，在回溯发生的时候，首先检查bitset，对于那些已经被置位的分支直接跳过，避免重复的距离计算。
\subsection{优先点树的插入}
在系统运行过程中，经常出现新的路径被插入的情况，这种情况下。如果每次都是将整个数据点集合重新进行初始建树，消耗会非常大。因此，有必要实现优先点树插入节点的相关算法。
\subsection{Insert操作算法概述}
优先点插入有以下几种情况。

第一，新插入的数据点所匹配的叶节点未满，则直接插入到该叶节点中。

第二，新插入的数据点所匹配的叶节点已满，但是其父节点分支数未满。则分裂匹配的叶节点，为父节点新增子叶节点，并且进行数据重分布。注意，分裂之后的数据重分布应该秉持均分的原则，以使空槽位尽可能均匀，从而使得后续的插入操作尽可能多地符合第一种情况，从而减少叶节点分裂和数据重分布的次数，从而提高性能。如图\ref{insert-show1}所示，数据点e本应插入在节点L的f之前，但是因为节点L已经满了，而节点P的分支数未满，此时将节点L分裂成两个新节点L2和L3,将节点L中原本相距节点P的优先点距离最远的数据点h,i分配给L3。以此实现了数据点e的插入。

\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/insert-show1.pdf}
  \caption{叶节点分裂算法示意图}\label{insert-show1}
\end{figure}

第三，新插入的数据点所匹配的叶节点已经满了，而且父节点的分支数也已经满了，不能再分裂出新的叶节点。这种情况下，采用以中心扩散的方式，寻找最邻接未满的兄弟节点，进行数据重分布。注意，次数的优先级应该是最近优先，因为单次Insert只会插入一个新的数据点，所以只要某一兄弟节点有一个空槽位，就能实现数据重分布，而以最近邻为优先是因为，重分布涉及到兄弟叶节点和目标叶节点之间的所有其他叶节点。两者之间的距离越远，需要重新分布的节点数就越多，消耗越大，反之，消耗越小。因此，此处以距离最近者优先。

\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/insert-show2.pdf}
  \caption{叶节点数据重分布算法示意图}\label{insert-show2}
\end{figure}

第四，新插入的数据点所匹配的叶节点，父节点以及所有的兄弟节点都已经满了，则向上回溯，找到第一个未满的祖先节点，如祖先节点的分支数未满，则优先进行目标分支的分裂。形成新的分支。
\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=4in]{new_FIGs/chapter4/insert-show3.pdf}
  \caption{分支分裂算法示意图}\label{insert-show3}
\end{figure}
\textbf{注意，在这种情况下，不能像叶节点数据进行简单的移动就解决问题，由于产生新分支意味着必须重新建立子树，才能将原分支的数据点和新数据均匀分开，以降低接下来插入操作的负载。}如图\ref{insert-show3}所示,当插入数据点u的时候，分裂节点lowerAncestor,产生节点newBranch，并将均分的数据集合分别建立新的叶节点。

\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=5in]{new_FIGs/chapter4/insert-show4.pdf}
  \caption{分支重分布算法示意图}\label{insert-show4}
\end{figure}
第五，如果祖先分支数已经满了，则寻找分支数据未满的子树的祖先进行数据重新分布。与分支分裂不同的是，分支之间的数据重分布并不涉及新的数结构的生成。与叶节点的数据重分布类似，只是数据节点的移动，只是多了一个深度搜索匹配叶节点的过程。如图\ref{insert-show4}所示，当要插入节点Ψ时，发现upperAncesor的分支notFullBranch的数据点数量不满，也就是说notFullBranch的叶节点有空槽位。此时将lowerAncestor和notFullBranch进行数据重分布，以
相对于UpperAncestor的优先点的距离作为挪动数据点的依据，将那些lowerAncestor中距离较大的k项移动到notFullBranch中，这里的k是两个分支节点总数的一半与lowerAncestor现有数据点量的差值。通过将k个数据点移动到lowerAncestor，完成insert的同时，也尽可能地均匀分布了数据，为后续的insert留出空位，以尽可能地减少成本较高的数据重分布操作。


第六，如果所有的位置都已经满了，则此时优先点树已经是一棵完全二叉树。此时，进行重新建树。这种情况下，确实可以类似于情况3那样，添加一个新的根节点，然后将旧根节点作为新根节点的一个分支，再以情况三的做法进行分支分裂。但这种情况下，分支分裂的消耗等同于重新建树。

\subsection{Insert操作算法细节1：根节点不分裂，树的高度不变}
优先点树的插入操作，类似于B树，但是比B树的插入消耗要大很多。因为B树的值通常都是相对于一个数据原点的可排序值，而优先点树的值则是相对于不同优先点的距离。如果要进行根节点分裂，则必须要重新对所有节点的数据进行重新划分，这样的消耗与重新建树没有区别。而初始建树的过程中以最小扇出度作为终止分裂的条件，则可以留出更多空位，为下一步的插入节约计算。

\subsection{Insert操作算法细节2：以最小扇出度作为初始建树的终止条件}
这样做的目的在于推迟节点分裂的结束，使得更多的分支数目被创建出来。那么在初始建树之后，就会预留出较多的叶节点空位。当进行插入新数据点时，叶节点的空位置将会显著减少数据重新分布和节点分裂的次数，提高性能。\textbf{但是也要注意的是，最小扇出度不能设的太小，因为节点元数据的存储都是以数组方式的线性存储，如果预留过多的空位，将会导致内存消耗大大增加。所以最小扇出度的设置要衡量插入操作与内存容量而定。}

\subsection{Insert操作算法细节3：分裂与数据重分布的优先级问题}
节点分裂能够更好地创造更多的叶节点空槽位，对于连续的插入操作非常友好。而且对于分支数较多的VpTree，节点分裂将对节点元数据的更改降到2 个分支以内，实际上可以做到以少量的距离计算代替大量的内存移动和比较操作。

而数据重分布的好处在于，能够通过在节点元数据保存数据点集合的信息来实现简单的移动就能完成数据点重新平衡的效果，从而减少了新的距离计算的消耗。这在分支数少的VpTree中性能良好。但是对于那些分支数多，跨分支范围很大的VpTree，则可能造成巨量的比较和移动操作。比如一个10路的VpTree 的，重分布的区间是从第二个分支到第八个分支，那就意味着这七个分支之间要进行数据移动。大量的比较和移动操作带来的消耗，同样可能带来性能灾难。而且如果分支的层级较高，重分布本身的距离计算也不会太少。

综上所述，节点分裂与重分布的性能消耗，与VpTree的分支数，分支距离，分支所在的层数都有关系，应该是一个动态计算的衡量结果。采用静态设置的方式，很有可能造成优先级上的偏颇，但本文出于实现的简单，静态地采用了优先分裂的原则，这显然不是性能最佳的实现。

\subsection{Insert操作算法细节4：存储数据点距离顺序}
在初始建树的同时，在节点中顺序保存当前节点数据点集合相对于上一级优先点的距离排序。这样做是为了在数据重分布的时候，避免重新的距离计算和排序，可以通过简单的数组元素移动和界标更新来完成，从而明显减少计算量，提升性能。但是这样做的代价是，重复保存了大量的id列表，消耗了额外的内存，而且在重分布的过程中，必须将顺序集合的内容进行同步更改，也带来时间消耗。而在数据点较少，距离计算量少的情况下，数据点顺序列表的存储消耗和维护成本，可能比直接进行距离计算还要严重。这其实也是一个动态衡量的策略，出于设计简单，本文对所有节点都默认采用了这种方式。

\subsection{Insert操作算法综述}
优先点树由于是基于不同优先点的距离索引，导致其插入操作本身消耗很大，很难找到轻量级的办法来实现。一方面，其在较高位置的节点分裂，几乎可以等同于重新建树。另一方面，为了保护检索性能，必须维持优先点树的天然平衡属性，不能简单地增长某棵子树的高度而破坏平衡，而维护平衡性最终还是要触发根节点的分裂。本文所采用的分裂优先重分布，存储额外元数据，延长建树分支等策略，都是以空间换取时间的做法。而这些静态策略的实际运行效果和具体的数据集合的情况有关，所以很可能并不是最佳的性能表现。
\subsection{插入算法流程图}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=7.5in]{new_FIGs/chapter4/vp-tree-insert-flow.pdf}
  \caption{Insert算法流程图}\label{vp-tree-insert-flow}
\end{figure}
\subsection{Insert算法实现1：已满叶节点的分裂}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=7.8in]{new_FIGs/chapter4/insert-code1.pdf}
  \caption{已满叶节点的分裂代码实现}\label{fullleafnode-split}
\end{figure}
\subsection{Insert算法实现2：叶节点数据重分布}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=7.8in]{new_FIGs/chapter4/insert-code2.pdf}
  \caption{叶节点数据重分布代码实现}\label{leafnode-redistribute}
\end{figure}
\subsection{Insert算法实现3：分支分裂}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in,height=6.8in]{new_FIGs/chapter4/insert-code3.pdf}
  \caption{分支分裂代码实现}\label{branch-split}
\end{figure}
\section{地图瓦片服务详细设计}
\subsection{概述}
地图瓦片服务的功能是为整个系统提供可视化地图数据的服务。它是基于Nodejs Express框架实现的，符合MapBox数据标准的数据微服务。\textbf{MapBox是业内通用标准，符合Mapbox标准是为了确保通用性}

如图~\ref{tile-server-structure} 所示，地图瓦片服务主要分为data、style、cache、logic和db这5个模块，以及对接db的各种数据库驱动组成。其各部分功能如下。
data\_service模块负责提供瓦片数据的读取，更新功能，是直接决定数据操作和数据状态的模块。style\_service模块是提供风格数据的模块，负责向调用发提供指定的风格数据，用于页面渲染。logic\_service是支持与地理相关的运算逻辑模块，例如坐标转换，bounding-box换算等。cache\_service是与瓦片数据缓存相关的功能模块，可以为瓦片数据配置不同的缓存策略。db\_service是面向各种不同数据库的通用访问接口层，其是data\_service与地理数据库交互的媒介。由于nodejs 支持的原型模式的多态，图中各部分的访问接口稳定不变，模块内部新增扩展实现或是更改实现就能无缝地交互和对接。\textbf{注意：style 模块的数据是静态的json文件，是存在文件系统中的，不经过数据库，所以不依赖与db\_service模块}

\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{new_FIGs/chapter4/tile-server-structure.pdf}
  \caption{tile-server整体结构图}\label{tile-server-structure}
\end{figure}

由于地图瓦片服务本身接口众多，出于篇幅考虑，本文只挑选其中比较关键，创新性较强的功能点地图局部更新功能，介绍具体实现，其他不予赘述。
\subsection{地图局部更新功能概述}
所谓地图局部更新，指的是一张完整地图，只更新全部地图地图的一小部分。比如中国地图中，只更新北京市地图。这一功能的价值很直观，在GTDS中很实用，而类似的其他地图瓦片服务均未提供此功能。本文根据莫卡托投影法的计算原理，实现了这一功能。

由于用户在浏览器界面上框选出来的，一定是经纬度坐标。因此，该功能的输入参数应该是一个north,south,west,east四个数值组成的矩形框和对应的zoom，也就是bounding-box。所以，要想更新对应的瓦片数据，就必须首先要根据像素精度，将经纬度坐标转换为栅格坐标，也就是对应的x,y，再将对应地图瓦片替换掉。这一过程中，为了避免起义，需要做边界和精度的检查。
\subsection{地图局部更新功能流程图}
\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{new_FIGs/chapter4/update_tile_1.pdf}
  \caption{地图局部更新功能流程图}\label{update_tile_1}
\end{figure}
如图\ref{update_tile_1}所示，这里值得注意的是，在流程中第二次检查，是对栅格坐标结果的检查。因为对于不同zoom，zoom值越大，地图的精度越高，更新设计的完整瓦片越多，反之则越少。那么对于那些zoom值较低的更新，其所计算出来的栅格坐标值可能不是完整的的瓦片，对于这种情况，要根据用户对精度的要求进行取舍，而取舍的前提要保证更新行为的一致性。具体可见后文。
\subsection{地图局部更新功能代码实现}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/tile_degree_compute.pdf}
  \caption{地图局部更新功能代码实现}\label{tile_degree_compute}
\end{figure}
\subsection{更新一致性的原理}
所谓的更新的一致性，指的是整体更新和分部更新结果的不一致。这主要是因为单纯的栅格坐标模糊取整很可能遗漏部分栅格瓦片，导致出现更新间隙的问题。对于这个问题的解决办法，是以bouding-box对一个TIle的侵占面积是否大于1/4作为是否更新的标准，如果超过1/4，则更新，否则不更新,具体理由如下。

1.首先判断用户bbox更新中设置的经纬度的差值在其所设定的zoom下，是否大于等于一个Tile的边长。如果用户划定的范围太小，要求的精度太高，则直接告知用户，在当前zoom下不能更新这个bbox。

2.如果bbox的长度和宽度都大于等于Tile的边长。那么在这种情况下，对于任意一个Tile的bbox划分，如果bbox的划分本身是严密的，没有缝隙的。那么，1个Tile能且只能被划分为4个bbox,1个Tile对划分的4个bbox中，至少有一个，其面积超过了1/4。以此作为是否更新的标准，能够保证每一个TIle至少被更新了一次，从而避免了局部更新漏掉某些Tile产生更新缝隙的问题。
\subsection{更新一致性的关键代码实现}
\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{new_FIGs/chapter4/consistancy-code.pdf}
  \caption{判断是否覆盖当前瓦片的代码}\label{consistancy-code}
\end{figure}
\section{本章总结}
本章分别描述了轨迹检索服务和地图瓦片服务的详细设计，主要介绍了Vptree初始建树，KNN问题检索以及地图瓦片局部更新功能这三个创新性较强的模块的设计要点和原理。通过流程图，类图来说明设计的思路，然后通过具体代码展示关键的实现细节。
