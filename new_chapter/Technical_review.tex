\chapter{相关技术概念综述}



\section{优先点树}
\subsection{NN问题}
Nearest Neighbour 问题，即最近邻居问题。指的是针对空间中的一个点集，定义一个距离函数d（这里的距离函数d包括但不仅限于欧几里得距离），那么对于一个给定的目标搜索点q，找到距离q 点的使距离d 最小一个点，这就是最近邻居问题。相对应的，要找到与q点距离最近的K个点，就是KNN问题。

针对NN问题，如果采用线性遍历的方式考虑所有点，将会造成很大的性能损耗。而一个比较合理的思路是，将二分查找的逻辑应用于点集合的检索，从而能将时间损耗降低为log(N)级别。也就是说，如果能够实现以nlog(N)的时间消耗将点集合建立成某种有序的数据结构。那么在搜索时，就可以通过类似于二分查找的方式达到log(N)级别的速度\cite{DBLP:conf/soda/Yianilos93}。

\subsection{优先点树概述}
vp-tree(vantage point tree),中文名称，优先点树，正是上述思路的一种实现。vp-tree从原理上说，是基于三角不等式进行递归分解的剪枝技术，其核心思想奠基了两种情况下的正确性。第一种，是在检索过程中，对于那些远远超出搜索范围的分支，就不需要进行搜索了。第二种，是当搜索目标点显然在某一个范围内的时候，外部的其他分支就都不必搜索了\cite{DBLP:journals/tc/FukunagaN75}。基于这两个原则，搜索点的数量和点的距离计算的次数都被大幅度地减少，从而显著提升了性能。

\subsection{优先点树的基本原理}
vp-tree的基本思路就是对点集合进行空间划分。第一步，要选择一个点作为vantage point，也就是优先点。第二步，集合中的所有点要计算自己与vp的距离。第三步，根据距离值的大小将点集合均分为两支，距离小于等于中值的为left/inside子集合，距离大于等于中值为right/outside子集合。第四步，以left/inside集合作为左子树的根节点，right/outside集合为右子树的根节点，再针对这两棵子树分别递归地进行上述划分，从而形成一颗平衡的二叉树。综上可知，vp-tree最终实现了整个点集合内部的一个球状分割。
\begin{figure}[htp]
  \centering
  \includegraphics[width=3.5in,height=3.5in]{new_FIGs/chapter2/vp_left_right1.pdf}
  \caption{vp-tree点集合分割示意图}\label{vp_left_rightCH2}
\end{figure}
\begin{figure}[htp]
  \centering
  \includegraphics[width=3.5in,height=3.5in]{new_FIGs/chapter2/vp_tree_decomposition.pdf}
  \caption{vp-tree空间分割示意图}\label{vp_tree_decompositionCH2}
\end{figure}
\subsection{最简单优先点树的结构和搜索过程}
如图2.3所示，即为一个最简单的vp-tree的内部结构，其包括一个用于只是优先点的VP-ID，一个中值mu和分别左右子树的两个指针。

搜索算法的思路是这样的。对于一次检索的目标点q和当前vp-tree的节点node，我们会设置一个容忍阈值u。首先计算q与node的vp之间的距离d,如果距离d>=mu+u,就舍弃左子树，只搜索右子树。反之，如果d<=mu-u,就舍弃右子树，只搜索左子树。如果mu-u<d<mu+u,那么无法完成剪枝，左右子树都要搜索。

这里显而易见的是，\textbf{容忍阈值u越小，剪枝的可能性越大，搜索性能越好}。因此u的选择应该是随着递归过程的推进而不断代之以距离q最小的距离，因为既然u是目前最小的距离，那么比u距离更大的点也就不必考虑了。因此，\textbf{如何实现算法使得容忍阈值以较快的速度收敛}，是代码实现的重点，我们将在第四章具体讨论。
\begin{figure}[htb]
  \centering
  \includegraphics[width=2.5in,height=3.5in]{new_FIGs/chapter2/vp-tree-simplest-structure.pdf}
  \caption{最简单vp-tree的结构示意图}\label{vp_tree_simplest_structureCH2}
\end{figure}
\begin{algorithm}[htp]
\caption{最简单vp-tree的搜索过程search}
\label{alg:simplest_vp_tree_search}
n $\leftarrow$ currentNode;\\
\If {n!=null}{
return
}
x $\leftarrow$ distance(q,n.vp);\\
\If {x \textless \ u} {
u $\leftarrow$ x;\\
best $\leftarrow$ n.vp;    
}
\If {x  $\geq$ \ mu-u}{
search(n.right);
}
\If{ x  $\leq$ \ mu+u}{
search(n.left);
}
\end{algorithm}
\section{Lucene与ElasticSearch}
\subsection{概述}
Lucene是一套用于全文检索和搜索的开放源代码程序库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程序接口，能够做全文索引和搜索，在Java开发环境里Lucene是一个成熟的免费开放源代码工具；就其本身而论，Lucene是现在并且是这几年，最受欢迎的免费Java信息检索程序库。

Elasticsearch是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎，具有HTTP Web接口和无模式JSON文档。Elasticsearch 可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0 个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。\cite{ES-Official}相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。\cite{ES-Performance}
\subsection{核心数据结构}
正排索引：正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。
这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。

倒排索引：倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。

\subsection{选择的原因}
天然分布式属性和自称服务的体系，节省了单独开发WebService的时间。ES-Geometry的良好兼容性。性能良好，安全稳定。
\section{地理相关技术概念介绍}
\subsection{地图瓦片数据}
瓦片地图金字塔模型是一种多分辨率层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变。首先确定地图服务平台所要提供的缩放级别的数量N，把缩放级别最高、地图比例尺最大的地图图片作为金字塔的底层，即第0层，并对其进行分块，从地图图片的左上角开始，从左至右、从上到下进行切割，分割成相同大小(比如256x256像素)的正方形地图瓦片，形成第0层瓦片矩阵;在第0层地图图片的基础上，按每2x2像素合成为一个像素的方法生成第1层地图图片，并对其进行分块，分割成与下一层相同大小的正方形地图瓦片，形成第1层瓦片矩阵;采用同样的方法生成第2层瓦片矩阵;…;如此下去，直到第N一1层，构成整个瓦片金字塔。
\subsection{墨卡托坐标}
墨卡托投影法（英语：Mercator projection），又称麦卡托投影法、正轴等角圆柱投影，是一种等角的圆柱形地图投影法。本投影法得名于法兰德斯出身的地理学家杰拉杜斯・墨卡托，他于1569年发表长202公分、宽124公分以此方式绘制的世界地图。在以此投影法绘制的地图上，经纬线于任何位置皆垂直相交，使世界地图可以绘制在一个长方形上。由于可显示任两点间的正确方位，航海用途的海图、航路图大都以此方式绘制。在该投影中线型比例尺在图中任意一点周围都保持不变，从而可以保持大陆轮廓投影后的角度和形状不变（即等角）；但墨卡托投影会使面积产生变形，极点的比例甚至达到了无穷大。
\section{Nodejs Express框架}
Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。